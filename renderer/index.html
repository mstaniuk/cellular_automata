<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    canvas {
      display: block;
    }
  </style>
</head>
<body>
<button id="toggle">Start/stop</button>
<canvas id="canvas"></canvas>

<script>
  ;(function() {
    let isAnimating = false;
    let lastTime = 0;
    let deltaTime = 0;
    let timePassed = 0;
    const timePerFrame = 0;
    const CELL_SIZE = 1;
    const WORLD_SIZE = 800;
    const toggleButton = document.getElementById('toggle');
    const canvas = document.getElementById('canvas');
    canvas.width = WORLD_SIZE*CELL_SIZE;
    canvas.height = WORLD_SIZE*CELL_SIZE;
    const ctx = canvas.getContext('2d');
    let shouldRender = false;

    function generateLookupTable() {
      /*
        ## Key structure:

        ### Schema
        yxxxxxxxx

        ### Definition
        y - state of current cell
        x - state of neighbour

        ### Positions
        x  x  x  x  x  x  x  x
        NW N  NE W  E  SW S  SE

        ## Values
        y = [0, 1]
        x = [0, 1]
      */
    }

    const pages = [
      (new Array(WORLD_SIZE).fill(0)).map(() => new Array(WORLD_SIZE).fill(false)),
      (new Array(WORLD_SIZE).fill(0)).map(() => new Array(WORLD_SIZE).fill(false)),
    ];
    let renderableCells = [];

    let currentPage = 0;

    for(let x = 0; x < WORLD_SIZE; x++) {
      for(let y = 0; y < WORLD_SIZE; y++) {
        const val = Math.random() > 0.6 ? 1 : 0;
        pages[0][x][y] = val;
        pages[1][x][y] = val;
        renderableCells.push([x,y]);
      }
    }

    function update(timestamp) {
      deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      timePassed = timePassed + deltaTime;

      if (timePassed < timePerFrame) {
        shouldRender = false;
        return;
      }
      renderableCells = [];
      shouldRender = true;
      timePassed = 0;

      currentPage = currentPage === 0 ? 1 : 0;
      const lastPage = currentPage === 0 ? 1 : 0;

      for(let x = 0; x < WORLD_SIZE; x++) {
        for(let y = 0; y < WORLD_SIZE; y++) {
          const cell = pages[lastPage][x][y];
          const directions = {
            north: y <= 0 ? WORLD_SIZE - 1 : y - 1,
            south: y >= WORLD_SIZE - 1 ? 0 : y + 1,
            west: x <= 0 ? WORLD_SIZE - 1 : x - 1,
            east: x >= WORLD_SIZE - 1 ? 0 : x + 1,
          }

          // Save neighbours to do some more complex cell lifecycle
          const liveNeighbours =
            pages[lastPage][directions.west][directions.north] +
            pages[lastPage][x][directions.north] +
            pages[lastPage][directions.east][directions.north] +
            pages[lastPage][directions.west][y] +
            pages[lastPage][directions.east][y] +
            pages[lastPage][directions.west][directions.south] +
            pages[lastPage][x][directions.south] +
            pages[lastPage][directions.east][directions.south];

          if ( cell && liveNeighbours < 2 ) {
            pages[currentPage][x][y] = false;
            continue;
          }

          if ( cell && liveNeighbours >= 2 && liveNeighbours <= 3) {
            pages[currentPage][x][y] = true;
            renderableCells.push([x, y]);
            continue;
          }
          if ( cell && liveNeighbours > 3 ) {
            pages[currentPage][x][y] = false;
            continue;
          }

          if ( !cell && liveNeighbours === 3 ) {
            pages[currentPage][x][y] = true;
            renderableCells.push([x, y]);
            continue;
          }

          if(cell) {
            renderableCells.push([x, y]);
          }

          pages[currentPage][x][y] = cell;
        }
      }
    }

    function render() {
      if(shouldRender) {
        ctx.clearRect(0, 0, WORLD_SIZE*CELL_SIZE, WORLD_SIZE*CELL_SIZE);

        for(let i = 0; i < renderableCells.length; i++) {
          ctx.fillRect(renderableCells[i][0]*CELL_SIZE, renderableCells[i][1]*CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }
    }

    function tick(timestamp) {
      update(timestamp);
      render();

      window.requestAnimationFrame((ts) => {
        if(isAnimating) {
          tick(ts);
        }
      });
    }

    toggleButton.addEventListener('click', () => {
      isAnimating = !isAnimating;
      lastTime = performance.now();
      tick(lastTime);
    })

    lastTime = performance.now();
    tick(lastTime);

  }())
</script>
</body>
</html>
