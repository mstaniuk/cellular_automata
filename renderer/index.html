<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    canvas {
      display: block;
    }
  </style>
</head>
<body>
<button id="toggle">Start/stop</button>
<canvas id="canvas"></canvas>

<script>
  ;(function() {
    let isAnimating = false;
    let lastTime = 0;
    let deltaTime = 0;
    let timePassed = 0;
    const timePerFrame = 0;
    const CELL_SIZE = 1;
    const WORLD_SIZE = 800;
    const toggleButton = document.getElementById('toggle');
    const canvas = document.getElementById('canvas');
    canvas.width = WORLD_SIZE*CELL_SIZE;
    canvas.height = WORLD_SIZE*CELL_SIZE;
    const ctx = canvas.getContext('2d');
    let shouldRender = false;

    function countCharOccurrences(str, char) {
      let ctr = 0;
      for(let i = 0; i < str.length; i++) {
        if(str.charAt(i) === char) ctr++;
      }
      return ctr;
    }

    function generateLookupTable() {
      /*
        ## Key structure:

        ### Schema
        yxxxxxxxx

        ### Definition
        y - state of current cell
        x - state of neighbour

        ### Positions
        x  x  x  x  x  x  x  x
        NW N  NE W  E  SW S  SE

        ## Values
        y = [0, 1]
        x = [0, 1]
      */
      const lot = {};
      const numberOfNeighboursStates = 0b11111111;

      for( let y = 0; y <= 1; y++) {
        for (let x = 0; x <= numberOfNeighboursStates; x++) {
          const liveNeighbours = countCharOccurrences(x.toString(2), '1');
          let val = y;

          if ( y && liveNeighbours < 2 ) {
            lot[y + x.toString(2).padStart(8, '0')] = 0;
            continue;
          }

          if ( y && liveNeighbours >= 2 && liveNeighbours <= 3) {
            lot[y + x.toString(2).padStart(8, '0')] = 1;
            continue;
          }
          if ( y && liveNeighbours > 3 ) {
            lot[y + x.toString(2).padStart(8, '0')] = 0;
            continue;
          }

          if ( !y && liveNeighbours === 3 ) {
            lot[y + x.toString(2).padStart(8, '0')] = 1;
            continue;
          }

          lot[y + x.toString(2).padStart(8, '0')] = val;
        }
      }

      return lot;
    }

    const LOT = generateLookupTable();

    const pages = [
      (new Array(WORLD_SIZE).fill(0)).map(() => new Array(WORLD_SIZE).fill(0)),
      (new Array(WORLD_SIZE).fill(0)).map(() => new Array(WORLD_SIZE).fill(0)),
    ];
    let renderableCells = [];

    let currentPage = 0;

    for(let x = 0; x < WORLD_SIZE; x++) {
      for(let y = 0; y < WORLD_SIZE; y++) {
        const val = Math.random() > 0.6 ? 1 : 0;
        pages[0][x][y] = val;
        pages[1][x][y] = val;
        renderableCells.push([x,y]);
      }
    }

    function update(timestamp) {
      deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      timePassed = timePassed + deltaTime;

      if (timePassed < timePerFrame) {
        shouldRender = false;
        return;
      }
      renderableCells = [];
      shouldRender = true;
      timePassed = 0;

      currentPage = currentPage === 0 ? 1 : 0;
      const lastPage = currentPage === 0 ? 1 : 0;

      for(let x = 0; x < WORLD_SIZE; x++) {
        for(let y = 0; y < WORLD_SIZE; y++) {
          const cell = pages[lastPage][x][y];
          const directions = {
            north: y <= 0 ? WORLD_SIZE - 1 : y - 1,
            south: y >= WORLD_SIZE - 1 ? 0 : y + 1,
            west: x <= 0 ? WORLD_SIZE - 1 : x - 1,
            east: x >= WORLD_SIZE - 1 ? 0 : x + 1,
          }

          const lotKey =
            '' +
            cell +
            pages[lastPage][directions.west][directions.north] +
            pages[lastPage][x][directions.north] +
            pages[lastPage][directions.east][directions.north] +
            pages[lastPage][directions.west][y] +
            pages[lastPage][directions.east][y] +
            pages[lastPage][directions.west][directions.south] +
            pages[lastPage][x][directions.south] +
            pages[lastPage][directions.east][directions.south];

          const nextState = LOT[lotKey];
          pages[currentPage][x][y] = nextState;
          if(nextState) renderableCells.push([x, y]);
        }
      }
    }

    function render() {
      if(shouldRender) {
        ctx.clearRect(0, 0, WORLD_SIZE*CELL_SIZE, WORLD_SIZE*CELL_SIZE);

        for(let i = 0; i < renderableCells.length; i++) {
          ctx.fillRect(renderableCells[i][0]*CELL_SIZE, renderableCells[i][1]*CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }
    }

    function tick(timestamp) {
      update(timestamp);
      render();

      window.requestAnimationFrame((ts) => {
        if(isAnimating) {
          tick(ts);
        }
      });
    }

    toggleButton.addEventListener('click', () => {
      isAnimating = !isAnimating;
      lastTime = performance.now();
      tick(lastTime);
    })

    lastTime = performance.now();
    tick(lastTime);

  }())
</script>
</body>
</html>
